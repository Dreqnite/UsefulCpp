# Странно рекурсивный шаблон
Данная идиома используется при программировании шаблонов в С++. Название CRTP (англ. Curiously Recurring Template Pattern) получило благодаря Джеймсу Коплиенту (James Coplien) ещё в 1995 году. Идиома широко используется в ATL и MFC от Microsoft, а также в библиотеке Boost (напр. `boost/operators.hpp`)

Смысл CRTP заключается в эмуляции поведения виртуальных функции при динамическом полиморфизме, однако без использования оного (используется compile-time статический полиморфизм). В примере, представленном в `CRTP.h`, имеется 2 класса:
* `Base` - базовый класс, из которого осуществляется обращение к методу производного класса;
* `Derived` - производный класс, который унаследован от шаблона `Base` с самим собой в качетсве параметра шаблона.

Для понимания этой идиомы необходимо использовать определение полного/неполного типа:  
**Неполный тип** - это тип, который описывает идентификатор, но не содержит информации, необходимой для определения идентификатора. Соответственно размер данного идентификатора невозможно определить. Класс будет считаться полным после закрывающей скобки `}`.

Класс `Derived` будет считаться полным только после того, как мы доберёмся до `;`, до этого момента он считается неполным. Таким образом в `Base<Derived>` инстанцируется неполным классом `Derived`. Шаблонный класс `Base`, который принимает неполный тип, накладывает на него некоторые ограничения. Например, псевдонимы вида:
```c++
class Derived : public Base<Derived>
{
	// ...
	using usefulType = bool;
	// ...
};
```
определённый в классе `Derived`, был бы не виден в базовом классе `Base`, если бы было использовано:
```c++
template <typename T>
class Base
{
	// ...
	using childUsefulType = typename T::type 
	// ...
};
```
Была бы выдана ошибка: `error: invalid use of incomplete type 'class Derived' using childUsefulType = typename T::type`. Однако внутри метода `Base<T>::call()` данный псевдоним позволяет компилироваться нормально. В `Base<T>::call()` осуществляется преобразование из типа `Base*` в тип `Derived*` с помощью `static_cast` для последующего вызова функции `call` из класса `Derived` - сущность compile-time статического полиморфизма.
